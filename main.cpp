#include <iostream>
#include "utils.h"

void task1(){
    /*
     * Урок №1. Знакомство, объявление, индексация и инициализация
    Задача 1. Банкетный стол
    По поводу успешного прохождения двумерных массивов собирается банкет, организуется стол на 12 персон, 2 из них -
    это места VIP, они расположены рядом друг к другу во главе стола. Стол протяжённый в длину, места расположены в два
    ряда. Каждый пришедший должен быть “упакован” соответствующим образом. Во-первых столовые приборы - их три на
    каждого человека (вилка, ложка, нож), плюс одна маленькая дополнительная ложечка для VIP-персон, для десерта.
    Это необходимо обеспечить. Следом тарелки, каждому по две - для первого и второго блюда, для VIP персон +1
    тарелка для десерта. Ну и конечно стул - один для каждого, минимум! Заведите соответствующие двумерные массивы для
    количества приборов, посуды и стульев и проинициализируйте их как следует.

    Однако, это ещё не всё. В ходе банкета, уже после инициализации, происходят некоторые события. Пришедшая на 5-ое
    место первого ряда дама пришла вместе с ребёнком и поэтому на данное место был приставлен ещё один стул.
    С третьего места во втором ряду в неизвестном направлении была украдена ложка. После этого одна из VIP персон
    (любая) поделилась своей ложкой с тем у кого она пропала, а сам стал есть суп десертной. За ненадобностью официант
    забрал у него одну десертную тарелку, ибо есть десерт ложкой, которая побывала уже в супе - не комильфо.
    Больше без происшествий!
     * */
    int cutlery[2][6], dishes[2][6], chairs[2][6];

    // initialization
    initArrayWithConstant(cutlery, 3);
    std::cout << "Cutlery initialized";
    printArray(cutlery);
    cutlery[0][0]++;
    cutlery[1][0]++;
    initArrayWithConstant(dishes, 2);
    std::cout << "Dishes initialized";
    printArray(dishes);
    dishes[0][0]++;
    dishes[1][0]++;
    initArrayWithConstant(chairs, 1);
    std::cout << "Chairs initialized";
    printArray(chairs);

    // things happen
    // woman w/ kid
    chairs[0][4]+=1;
    std::cout << "chairs changed";
    printArray(chairs);
    // spoon got stolen
    cutlery[1][2]--;
    std::cout << "Cutlery changed";
    printArray(cutlery);
    // vip saves the day
    cutlery[0][0]--;
    cutlery[1][2]++;
    std::cout << "Cutlery changed";
    printArray(cutlery);
    // dessert is sacrificed
    dishes[0][0]--;
    std::cout << "Dishes changed";
    printArray(dishes);
}

void task2(){
/*
 Задача 2. Крестики-нолики

Старинная-добрая игра на страницах всех школьных тетрадей. Поле размером 3х3 представлено в виде двумерного массива
с типом элементов char. Помните тот символьный тип из предыдущего модуля? Теперь он нам и пригодится. Участвуют два
игрока, которые ходят по очереди и ставят в указанные ими в стандартном вводе координаты свой символ - ‘X’ или ‘O’
(буквы латинского алфавита). Как только у одного из игроков будет установлено подряд три крестика или три нолика -
он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено - объявляется ничья. Для
простоты, мы не будем рассматривать диагональные совпадения, а только строго вертикальные либо строго горизонтальные.

Изначально всё поле инициализируется символом пробела - ‘ ‘. Это можно сделать сразу при объявлении, либо с помощью
вложенного цикла. На каждом ходе, при занятой клетке или при неверных координатах этой клетки должно быть выведено
сообщение и игрок должен указать координаты клетки повторно. После каждого хода надо выводить в консоль текущее
состояние всего игрового поля, для наглядности.

Сделаю ещё одну небольшую подсказку. Проверку на победу игрока, которую надо осуществлять после каждого хода, можно
сделать с помощью вложенного цикла, сразу проверяя и вертикаль и горизонталь а как именно - попробуйте догадаться сами.
 * */
    char field[3][3];
    int result = 0;
    initArrayWithConstant(field, ' ');
    while (true){
//        X turn
        ticTacToeEnter('X', field);
        printArray(field);
        if (ticTacToeCheckVIctory('X', field)){
            std::cout << "X won" << std::endl;
            break;
        }
        else if(!ticTacToeCheckKeepContinue(field)){
            std::cout << "draw" << std::endl;
            break;
        }
//        0 turn
        ticTacToeEnter('0', field);
        printArray(field);
        if (ticTacToeCheckVIctory('0', field)){
            std::cout << "0 won" << std::endl;
            break;
        }
        else if(!ticTacToeCheckKeepContinue(field)){
            std::cout << "draw" << std::endl;
            break;
        }
    }
}

void task3(){
    /*
     Задача 3. Проход змейкой
     Довольно абстрактная, но интересная задача. У нас есть двумерный массив целых чисел размером 5 на 5 элементов.
     Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации. Элементы должны
     быть инициализированы не последовательно, а змейкой. Т.е. в конце каждой строки мы не должны переходить к первому
     элементу следующей строки, но начнём наоборот — с последнего элемента и так далее. В итоге, в конечном отображении
     нашего массива числа должны быть упорядочены по возрастанию но змеевидно от строки к строке. Сама же
     последовательность чисел — это простое линейное возрастание от 0 до 24, для её учёта можно завести отдельную
     переменную.

    Попытайтесь решить эту задачу, используя минимальное количество временных переменных и без условных переходов if.
     Если вы найдёте эту самую формулу индексации — будет замечательно! Предупреждаю, она может быть весьма витиеватая.
     * */
    int result[5][5];

    for (int i = 0; i < 25; i++){
        result[i / 5][i % 5] = i;
    }

    for (int i = 0; i < 5; i++){
        for(int j = 0; j < 5; j++){
            std::cout << result[i][j] << " ";
        }
        std::cout << std::endl;
    }
}

void task4(){
    /*
    Задача 4. Равенство матриц

    Требуется реализовать небольшую программу для сравнения двух двумерных матриц размерами 4х4 на предмет их полного
    равенства. Программа принимает на вход две целочисленные матрицы A и B, которые вводятся с помощью std::cin и
    сравнивает их на предмет полного равенства. Если матрицы равны, то об этом сообщается в стандартном выводе. Алгоритм
    должен быть по возможности оптимальным и не проводить лишних операций.
     * */
    int a[4][4], b[4][4];
    enterMatrix(a);
    enterMatrix(b);

    if (checkMatrixEquality(a, b)){
        std::cout << "equal" << std::endl;
    } else{
        std::cout << "not equal" << std::endl;
    }
}

void task5(){
    /*
    Задача 5. Диагональная матрица

    Задание. Для вещественной матрицы M размером 4х4 надо осуществить её преобразование в диагональную. Напомню, что
    диагональная матрица — это такая матрица, у которой все элементы вне диагонали равны нулю. Диагональ матрицы, в свою
    очередь — это все элементы, расположенные по диагонали от первого элемента первой строки до последнего элемента
    последней строки. Матрица M вводится пользователем через стандартный ввод, как и раньше. Итоговую диагональную
    матрицу можно расположить на месте прежней матрицы M, не используя дополнительных переменных. Результат требуется
    вывести в консоль для проверки. Ищите именно оптимальное решение — оно довольно простое.
     * */

    float matrix[4][4];

    enterMatrix(matrix);

    for(int i = 0; i < 4; i++){
        for(int j = 0; j < 4; j++){
            matrix[i][j] *= (float) (i == j);
        }
    }

    for (int i = 0; i < 4; i++){
        for(int j = 0; j < 4; j++){
            std::cout << matrix[i][j] << " ";
        }
        std::cout << std::endl;
    }

}

void task6(){

    /*
     * Задача 6. Умножение матрицы на вектор

    Реализуйте частный случай умножения матрицы на матрицу, а именно — умножение вектора на матрицу. Данная операция
     также весьма распространена в компьютерной индустрии в целом и в компьютерное графике в частности, поэтому это
     будет хорошим упражнением.
    Итак, у нас есть 4-х компонентный вектор V представленный с помощью массива, и матрица M размером 4х4, представленная
     в виде двумерного массива. Их произведением будет новый 4-х компонентный вектор R. Его компоненты будут суммой
     произведений компонент вектора V на строку матрицы M. Индекс столбца при этом равен индексу соответствующей
     компоненты вектора R, который мы и рассчитываем в текущий момент времени.
    Все входные данные, матрица M и вектор V вносятся из пользовательского ввода.  Итоговый вектор R надо вывести в
     консоль (std::cout). Тип данных элементов - всегда float. Желательно реализовать этот алгоритм с помощью вложенного
     цикла на умножение колонки.
     * */
    float V[4], M[4][4], R[4];

    enterVector(V);
    enterMatrix(M);

    for (int i = 0; i < 4; ++i){
        R[i] = 0.0;
        for (int j = 0; j < 4; ++j){
            R[i] += M[i][j] * V[j];
        }
    }

    for (float r : R){
        std::cout << r << std::endl;
    }
}

void task7(){
    /*
     * Задача 7. Пупырка

    После посылки из Китая осталась спец. плёнка для бережной перевозки груза — пупырка. Всего в пупырке 12 на 12
     шариков-пузырьков. Состояние любого пузырька — это всегда либо он целый, либо нет, т.е. true или false
     (тип массива bool). Для начала, требуется реализовать отдельную функцию инициализации пупырки начальным состоянием
     — полностью целая пупырка, т.е. все элементы true. Но это только самое начало.

    Программа заключается в последовательном лопанье целых регионов пузырьков. Перед каждым таким лопаньем надо
     показывать пользователю полностью всю плёнку: o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в
     отдельную функцию. Итак, как выглядит само лопанье. Пользователь вводит две координаты: координаты начала региона и
     конца прямоугольного региона. Сама процедура лопанья пузырей должна быть реализована с помощью отдельной функции,
     все аргументы должны проверяться на их валидность, что они в в рамках диапазона возможных значений — иначе должна
     быть выведена ошибка. После лопанья каждого пузыря, который не был ещё лопнут до того, в консоль должно выводиться
     сообщение “Pop!”.

    Лопанье должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает
     выполнение. В принципе, вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, т.к. она
     выполняется после каждого лопанья.
    Лопанье должно продолжаться до последнего пузырька. Как только вся пупырка потрачена, программа заканчивает
     выполнение. В принципе, вы можете подсчитать окончание в самой функции по отображению пузырьков плёнки, т.к. она
     выполняется после каждого лопанья.


     * */

    bool bubbles[12][12];
    int row, col = -1;
    initBubbles(bubbles);
    while(bubblesAvailable(bubbles)){
        printBubbles(bubbles);
        do {
            enterData(row, 0, 12, "row");
            enterData(col, 0, 12, "column");
        } while (!bubbles[row][col]);
        bubbles[row][col] = false;
        std::cout << "Pop!" << std::endl;
    }
}

void task8(){
    /*
    Задача 8. Почти-Майнкрафт

    Нам всё-таки предстоит сделать некое подобие Майнкрафта. Миллионов не обещаю, но это довольно интересная задача на
     пространственное мышление. У нас есть небольшой квадратный ландшафт, размером 5х5 секторов. В каждом секторе
     располагается блок (столбик) ландшафта, максимальная высота которого — это 10 блоков. Текущая высота каждого такого
     блока задаётся пользователем вначале программы. Итоговая задача — используя трёхмерный массив вывести в стандартный
     вывод горизонтальное сечение (или горизонтальный срез) нашего небольшого мира. Сам мир как раз должен быть
     представлен в виде трёхмерного массива. Его горизонтальный срез стало быть — это двумерный массив, который надо
     отобразить в виде единиц и нулей. 0 — это отсутствие элемента на данном уровне в данной точке, 1 — элемент есть.
     Уровень среза от 0 до 9 включительно — также задаётся в стандартном вводе.
     * */
    bool bins[5][5][10];
    int projectionHeight = 0;
    enterBins(bins);
    enterData(projectionHeight, 0, 10, "projection height");
    std::cout << " ";
    for(int i = 0; i < 5; ++i) std::cout << " _";
    std::cout << std::endl;
    for (int i = 0; i < 5; ++i){
        std::cout << "|";
        for (int j = 0; j < 5; ++j){
            if (bins[i][j][projectionHeight]){
                std::cout << "X ";
            }
            else{
                std::cout << "  ";
            }
        }
        std::cout << "|" <<std::endl;

    }
    std::cout << " ";
    for(int i = 0; i < 5; ++i) std::cout << " -";
    std::cout << std::endl;
}

void task9(){
    /*
    Морской бой
    Требуется реализовать упрощённую игру в Морской бой. Игровое поле размером 10 на 10 клеток. Участвует двое игроков.
     В арсенале каждого из них: 4 маленьких кораблика размером в одну клетку, 3 небольших корабля размером в две клетки,
     2 средних корабля размером в три клетки и один большой корабль размером в четыре клетки. Для простоты, клетки поля
     пронумерованы по вертикали от 0 до 9, и по горизонтали также от 0 до 9. Мы не будем использовать классические
     наименования клеток, такие как B4, C6, а просто два индекса. Вначале игроки по очереди расставляют корабли, начиная
     с самых маленьких и заканчивая большими. Маленькие корабли в одну клетку расставляются с помощью указания лишь
     одной клетки-точки на поле, к примеру 2,1. Корабли размерностью от двух клеток и выше, расставляются с помощью
     координат их начала и конца, к примеру: 0,1 - 0,3. Корабли могут быть установлены только строго вертикально, или
     горизонтально. Установка корабля по диагонали — недопустимо, в случае которого об этом тоже надо сообщить
     пользователю. Если корабль не может быть размещён на заданных клетках из-за того, что он столкнётся с другим
     кораблём (окажется на его клетках) или выйдет за пределы поля вообще, то игроку должно быть сделано предупреждение,
     после которого он должен переставить корабль на новые валидные координаты. Замечу, в нашем упрощённом варианте
     игры, мы не будем обсчитывать соприкосновения кораблей друг с другом, а потому корабли вполне можно будет размещать
     друг к другу вплотную — борт к борту. После того как все корабли были расставлены начинается игра. Игроки по
     очереди атакуют друг друга, называя координаты выстрела. После выстрела, в консоль выводится информация о его
     результате: попал или мимо. Если выстрел успешен, клетка, на которой был корабль (или его фрагмент) затирается и
     становится пустой. Игра заканчивается тогда, когда все корабли одной из сторон будут полностью уничтожены.
     Как только это произойдёт в консоль выводится информация с номером игрока, который победил.
     * */
    // initialize field and ships
    // field - 10x10 array of ints. f[i][j] may be one of:
    // empty cell, no ships, no hits, f[i][j] == 0
    // intact ship cell f[i][j] == ship_id
    // miss cell f[i][j] == -9001
    // hit cell f[i][j] == -ship_id
    // ships are stored in an 10x2 array. rows - ship_id, cols - ship coords
    // ship_ids: 1..4 - single-deck, 5..7 - double-deck, 8,9 - three-deck, 10 - four-deck
    int field1[10][10], field2[10][10];
    int hits1[10], hits2[10];
    int decks[10] = {1, 1, 1, 1, 2, 2, 2, 3, 3, 4};
    bool victory = false;

    for (int i = 0; i < 10; ++i){
        hits1[i] = 0;
        hits2[i] = 0;
        for (int j = 0; j < 10; ++j){
            field1[i][j] = 0;
            field2[i][j] = 0;
        }
    }
    // player1 setup
    setupShips(field1, hits1);
    // player2 setup
    setupShips(field2, hits2);
    // while not victory
//    std::cout << "Player1 field" << std::endl;
//    printField(field1, true);
//    std::cout << "Player2 field" << std::endl;
//    printField(field2, true);
    while (true){
        // player1 turn
        std::cout << "Player1, ";
        victory = takeShot(field2, hits2, decks);
        // check victory
        if (victory) {
            std::cout << "Player1 wins!" << std::endl;
            break;
        }
        // player2 turn
        std::cout << "Player2, ";
        victory = takeShot(field1, hits1, decks);
        if (victory) {
            std::cout << "Player2 wins!" << std::endl;
            break;
        }
    }


}

int main() {
//    task1();
//    task2();
//    task3();
//    task4();
//    task5();
//    task6();
//    task7();
//    task8();
    task9();
    return 0;
}
